{"ast":null,"code":"const crypto = require(\"crypto\");\n\nconst url = require(\"url\");\n\nconst auth = require(\"./auth\");\n\nconst errors = require(\"./errors\");\n\nconst events = require(\"./events\");\n\nconst requests = require(\"./requests\");\n\nconst PusherConfig = require(\"./pusher_config\");\n\nconst Token = require(\"./token\");\n\nconst WebHook = require(\"./webhook\");\n\nconst NotificationClient = require(\"./notification_client\");\n\nconst validateChannel = function (channel) {\n  if (typeof channel !== \"string\" || channel === \"\" || channel.match(/[^A-Za-z0-9_\\-=@,.;]/)) {\n    throw new Error(\"Invalid channel name: '\" + channel + \"'\");\n  }\n\n  if (channel.length > 200) {\n    throw new Error(\"Channel name too long: '\" + channel + \"'\");\n  }\n};\n\nconst validateSocketId = function (socketId) {\n  if (typeof socketId !== \"string\" || socketId === \"\" || !socketId.match(/^\\d+\\.\\d+$/)) {\n    throw new Error(\"Invalid socket id: '\" + socketId + \"'\");\n  }\n};\n\nconst validateUserId = function (userId) {\n  if (typeof userId !== \"string\" || userId === \"\") {\n    throw new Error(\"Invalid user id: '\" + userId + \"'\");\n  }\n};\n\nconst validateUserData = function (userData) {\n  if (userData == null || typeof userData !== \"object\") {\n    throw new Error(\"Invalid user data: '\" + userData + \"'\");\n  }\n\n  validateUserId(userData.id);\n};\n/** Provides access to Pusher's REST API, WebHooks and authentication.\n *\n * @constructor\n * @param {Object} options\n * @param {String} [options.host=\"api.pusherapp.com\"] API hostname\n * @param {String} [options.notification_host=\"api.pusherapp.com\"] Notification API hostname\n * @param {Boolean} [options.useTLS=false] whether to use TLS\n * @param {Boolean} [options.encrypted=false] deprecated; renamed to `useTLS`\n * @param {Boolean} [options.notification_encrypted=false] whether to use TLS for notifications\n * @param {Integer} [options.port] port, default depends on the scheme\n * @param {Integer} options.appId application ID\n * @param {String} options.key application key\n * @param {String} options.secret application secret\n * @param {Integer} [options.timeout] request timeout in milliseconds\n * @param {Agent} [options.agent] http agent to use\n */\n\n\nfunction Pusher(options) {\n  this.config = new PusherConfig(options);\n  const notificationOptions = Object.assign({}, options, {\n    host: options.notificationHost,\n    encrypted: options.notificationEncrypted\n  });\n  this.notificationClient = new NotificationClient(notificationOptions);\n}\n/** Create a Pusher instance using a URL.\n *\n * URL should be in SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID form.\n *\n * @param {String} pusherUrl URL containing endpoint and app details\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the URL and options\n */\n\n\nPusher.forURL = function (pusherUrl, options) {\n  const apiUrl = url.parse(pusherUrl);\n  const apiPath = apiUrl.pathname.split(\"/\");\n  const apiAuth = apiUrl.auth.split(\":\");\n  return new Pusher(Object.assign({}, options || {}, {\n    scheme: apiUrl.protocol.replace(/:$/, \"\"),\n    host: apiUrl.hostname,\n    port: parseInt(apiUrl.port, 10) || undefined,\n    appId: parseInt(apiPath[apiPath.length - 1], 10),\n    key: apiAuth[0],\n    secret: apiAuth[1]\n  }));\n};\n/** Create a Pusher instance using a cluster name.\n *\n * @param {String} cluster cluster name\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the cluster and options\n */\n\n\nPusher.forCluster = function (cluster, options) {\n  return new Pusher(Object.assign({}, options || {}, {\n    host: \"api-\" + cluster + \".pusher.com\"\n  }));\n};\n/** Returns a signature for given socket id, channel and socket data.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\n\n\nPusher.prototype.authorizeChannel = function (socketId, channel, data) {\n  validateSocketId(socketId);\n  validateChannel(channel);\n  return auth.getSocketSignature(this, this.config.token, channel, socketId, data);\n};\n/** Returns a signature for given socket id, channel and socket data.\n *\n *  DEPRECATED. Use authorizeChannel.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\n\n\nPusher.prototype.authenticate = Pusher.prototype.authorizeChannel;\n/** Returns a signature for given socket id and user data.\n *\n * @param {String} socketId socket id\n * @param {Object} userData user data\n * @returns {String} authentication signature\n */\n\nPusher.prototype.authenticateUser = function (socketId, userData) {\n  validateSocketId(socketId);\n  validateUserData(userData);\n  return auth.getSocketSignatureForUser(this.config.token, socketId, userData);\n};\n/** Sends an event to a user.\n *\n * Event name can be at most 200 characters long.\n *\n * @param {String} userId user id\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\n\n\nPusher.prototype.sendToUser = function (userId, event, data) {\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\");\n  }\n\n  validateUserId(userId);\n  return events.trigger(this, [`#server-to-user-${userId}`], event, data);\n};\n/** Terminate users's connections.\n *\n *\n * @param {String} userId user id\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\n\n\nPusher.prototype.terminateUserConnections = function (userId) {\n  validateUserId(userId);\n  return this.post({\n    path: `/users/${userId}/terminate_connections`,\n    body: {}\n  });\n};\n/** Triggers an event.\n *\n * Channel names can contain only characters which are alphanumeric, '_' or '-'\n * and have to be at most 200 characters long.\n *\n * Event name can be at most 200 characters long.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {String|String[]} channel list of at most 100 channels\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @param {Object} [params] additional optional request body parameters\n * @param {String} [params.socket_id] id of a socket that should not receive the event\n * @param {String} [params.info] a comma separate list of attributes to be returned in the response. Experimental, see https://pusher.com/docs/lab#experimental-program\n * @see RequestError\n */\n\n\nPusher.prototype.trigger = function (channels, event, data, params) {\n  if (params && params.socket_id) {\n    validateSocketId(params.socket_id);\n  }\n\n  if (!(channels instanceof Array)) {\n    // add single channel to array for multi trigger compatibility\n    channels = [channels];\n  }\n\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\");\n  }\n\n  if (channels.length > 100) {\n    throw new Error(\"Can't trigger a message to more than 100 channels\");\n  }\n\n  for (let i = 0; i < channels.length; i++) {\n    validateChannel(channels[i]);\n  }\n\n  return events.trigger(this, channels, event, data, params);\n};\n/* Triggers a batch of events\n *\n * @param {Event[]} An array of events, where Event is\n * {\n *   name: string,\n *   channel: string,\n *   data: any JSON-encodable data,\n *   socket_id: [optional] string,\n *   info: [optional] string experimental, see https://pusher.com/docs/lab#experimental-program\n * }\n */\n\n\nPusher.prototype.triggerBatch = function (batch) {\n  return events.triggerBatch(this, batch);\n};\n\nPusher.prototype.notify = function () {\n  this.notificationClient.notify.apply(this.notificationClient, arguments);\n};\n/** Makes a POST request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @see RequestError\n */\n\n\nPusher.prototype.post = function (options) {\n  return requests.send(this.config, Object.assign({}, options, {\n    method: \"POST\"\n  }));\n};\n/** Makes a GET request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @see RequestError\n */\n\n\nPusher.prototype.get = function (options) {\n  return requests.send(this.config, Object.assign({}, options, {\n    method: \"GET\"\n  }));\n};\n/** Creates a WebHook object for a given request.\n *\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n * @returns {WebHook}\n */\n\n\nPusher.prototype.webhook = function (request) {\n  return new WebHook(this.config.token, request);\n};\n/** Builds a signed query string that can be used in a request to Pusher.\n *\n * @param {Object} options\n * @param {String} options.method request method\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @returns {String} signed query string\n */\n\n\nPusher.prototype.createSignedQueryString = function (options) {\n  return requests.createSignedQueryString(this.config.token, options);\n};\n\nPusher.prototype.channelSharedSecret = function (channel) {\n  return crypto.createHash(\"sha256\").update(Buffer.concat([Buffer.from(channel), this.config.encryptionMasterKey])).digest();\n};\n/** Exported {@link Token} constructor. */\n\n\nPusher.Token = Token;\n/** Exported {@link RequestError} constructor. */\n\nPusher.RequestError = errors.RequestError;\n/** Exported {@link WebHookError} constructor. */\n\nPusher.WebHookError = errors.WebHookError;\nmodule.exports = Pusher;","map":{"version":3,"names":["crypto","require","url","auth","errors","events","requests","PusherConfig","Token","WebHook","NotificationClient","validateChannel","channel","match","Error","length","validateSocketId","socketId","validateUserId","userId","validateUserData","userData","id","Pusher","options","config","notificationOptions","Object","assign","host","notificationHost","encrypted","notificationEncrypted","notificationClient","forURL","pusherUrl","apiUrl","parse","apiPath","pathname","split","apiAuth","scheme","protocol","replace","hostname","port","parseInt","undefined","appId","key","secret","forCluster","cluster","prototype","authorizeChannel","data","getSocketSignature","token","authenticate","authenticateUser","getSocketSignatureForUser","sendToUser","event","trigger","terminateUserConnections","post","path","body","channels","params","socket_id","Array","i","triggerBatch","batch","notify","apply","arguments","send","method","get","webhook","request","createSignedQueryString","channelSharedSecret","createHash","update","Buffer","concat","from","encryptionMasterKey","digest","RequestError","WebHookError","module","exports"],"sources":["/home/hhelsinki/sandbox-react/react-app/node_modules/pusher/lib/pusher.js"],"sourcesContent":["const crypto = require(\"crypto\")\nconst url = require(\"url\")\n\nconst auth = require(\"./auth\")\nconst errors = require(\"./errors\")\nconst events = require(\"./events\")\nconst requests = require(\"./requests\")\n\nconst PusherConfig = require(\"./pusher_config\")\nconst Token = require(\"./token\")\nconst WebHook = require(\"./webhook\")\nconst NotificationClient = require(\"./notification_client\")\n\nconst validateChannel = function (channel) {\n  if (\n    typeof channel !== \"string\" ||\n    channel === \"\" ||\n    channel.match(/[^A-Za-z0-9_\\-=@,.;]/)\n  ) {\n    throw new Error(\"Invalid channel name: '\" + channel + \"'\")\n  }\n  if (channel.length > 200) {\n    throw new Error(\"Channel name too long: '\" + channel + \"'\")\n  }\n}\n\nconst validateSocketId = function (socketId) {\n  if (\n    typeof socketId !== \"string\" ||\n    socketId === \"\" ||\n    !socketId.match(/^\\d+\\.\\d+$/)\n  ) {\n    throw new Error(\"Invalid socket id: '\" + socketId + \"'\")\n  }\n}\n\nconst validateUserId = function (userId) {\n  if (typeof userId !== \"string\" || userId === \"\") {\n    throw new Error(\"Invalid user id: '\" + userId + \"'\")\n  }\n}\n\nconst validateUserData = function (userData) {\n  if (userData == null || typeof userData !== \"object\") {\n    throw new Error(\"Invalid user data: '\" + userData + \"'\")\n  }\n  validateUserId(userData.id)\n}\n\n/** Provides access to Pusher's REST API, WebHooks and authentication.\n *\n * @constructor\n * @param {Object} options\n * @param {String} [options.host=\"api.pusherapp.com\"] API hostname\n * @param {String} [options.notification_host=\"api.pusherapp.com\"] Notification API hostname\n * @param {Boolean} [options.useTLS=false] whether to use TLS\n * @param {Boolean} [options.encrypted=false] deprecated; renamed to `useTLS`\n * @param {Boolean} [options.notification_encrypted=false] whether to use TLS for notifications\n * @param {Integer} [options.port] port, default depends on the scheme\n * @param {Integer} options.appId application ID\n * @param {String} options.key application key\n * @param {String} options.secret application secret\n * @param {Integer} [options.timeout] request timeout in milliseconds\n * @param {Agent} [options.agent] http agent to use\n */\nfunction Pusher(options) {\n  this.config = new PusherConfig(options)\n  const notificationOptions = Object.assign({}, options, {\n    host: options.notificationHost,\n    encrypted: options.notificationEncrypted,\n  })\n  this.notificationClient = new NotificationClient(notificationOptions)\n}\n\n/** Create a Pusher instance using a URL.\n *\n * URL should be in SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID form.\n *\n * @param {String} pusherUrl URL containing endpoint and app details\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the URL and options\n */\nPusher.forURL = function (pusherUrl, options) {\n  const apiUrl = url.parse(pusherUrl)\n  const apiPath = apiUrl.pathname.split(\"/\")\n  const apiAuth = apiUrl.auth.split(\":\")\n\n  return new Pusher(\n    Object.assign({}, options || {}, {\n      scheme: apiUrl.protocol.replace(/:$/, \"\"),\n      host: apiUrl.hostname,\n      port: parseInt(apiUrl.port, 10) || undefined,\n      appId: parseInt(apiPath[apiPath.length - 1], 10),\n      key: apiAuth[0],\n      secret: apiAuth[1],\n    })\n  )\n}\n\n/** Create a Pusher instance using a cluster name.\n *\n * @param {String} cluster cluster name\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the cluster and options\n */\nPusher.forCluster = function (cluster, options) {\n  return new Pusher(\n    Object.assign({}, options || {}, {\n      host: \"api-\" + cluster + \".pusher.com\",\n    })\n  )\n}\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\nPusher.prototype.authorizeChannel = function (socketId, channel, data) {\n  validateSocketId(socketId)\n  validateChannel(channel)\n\n  return auth.getSocketSignature(\n    this,\n    this.config.token,\n    channel,\n    socketId,\n    data\n  )\n}\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n *  DEPRECATED. Use authorizeChannel.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\nPusher.prototype.authenticate = Pusher.prototype.authorizeChannel\n\n/** Returns a signature for given socket id and user data.\n *\n * @param {String} socketId socket id\n * @param {Object} userData user data\n * @returns {String} authentication signature\n */\nPusher.prototype.authenticateUser = function (socketId, userData) {\n  validateSocketId(socketId)\n  validateUserData(userData)\n\n  return auth.getSocketSignatureForUser(this.config.token, socketId, userData)\n}\n\n/** Sends an event to a user.\n *\n * Event name can be at most 200 characters long.\n *\n * @param {String} userId user id\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\nPusher.prototype.sendToUser = function (userId, event, data) {\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\")\n  }\n  validateUserId(userId)\n  return events.trigger(this, [`#server-to-user-${userId}`], event, data)\n}\n\n/** Terminate users's connections.\n *\n *\n * @param {String} userId user id\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\nPusher.prototype.terminateUserConnections = function (userId) {\n  validateUserId(userId)\n  return this.post({ path: `/users/${userId}/terminate_connections`, body: {} })\n}\n\n/** Triggers an event.\n *\n * Channel names can contain only characters which are alphanumeric, '_' or '-'\n * and have to be at most 200 characters long.\n *\n * Event name can be at most 200 characters long.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {String|String[]} channel list of at most 100 channels\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @param {Object} [params] additional optional request body parameters\n * @param {String} [params.socket_id] id of a socket that should not receive the event\n * @param {String} [params.info] a comma separate list of attributes to be returned in the response. Experimental, see https://pusher.com/docs/lab#experimental-program\n * @see RequestError\n */\nPusher.prototype.trigger = function (channels, event, data, params) {\n  if (params && params.socket_id) {\n    validateSocketId(params.socket_id)\n  }\n  if (!(channels instanceof Array)) {\n    // add single channel to array for multi trigger compatibility\n    channels = [channels]\n  }\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\")\n  }\n  if (channels.length > 100) {\n    throw new Error(\"Can't trigger a message to more than 100 channels\")\n  }\n  for (let i = 0; i < channels.length; i++) {\n    validateChannel(channels[i])\n  }\n  return events.trigger(this, channels, event, data, params)\n}\n\n/* Triggers a batch of events\n *\n * @param {Event[]} An array of events, where Event is\n * {\n *   name: string,\n *   channel: string,\n *   data: any JSON-encodable data,\n *   socket_id: [optional] string,\n *   info: [optional] string experimental, see https://pusher.com/docs/lab#experimental-program\n * }\n */\nPusher.prototype.triggerBatch = function (batch) {\n  return events.triggerBatch(this, batch)\n}\n\nPusher.prototype.notify = function () {\n  this.notificationClient.notify.apply(this.notificationClient, arguments)\n}\n\n/** Makes a POST request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @see RequestError\n */\nPusher.prototype.post = function (options) {\n  return requests.send(\n    this.config,\n    Object.assign({}, options, { method: \"POST\" })\n  )\n}\n\n/** Makes a GET request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @see RequestError\n */\nPusher.prototype.get = function (options) {\n  return requests.send(\n    this.config,\n    Object.assign({}, options, { method: \"GET\" })\n  )\n}\n\n/** Creates a WebHook object for a given request.\n *\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n * @returns {WebHook}\n */\nPusher.prototype.webhook = function (request) {\n  return new WebHook(this.config.token, request)\n}\n\n/** Builds a signed query string that can be used in a request to Pusher.\n *\n * @param {Object} options\n * @param {String} options.method request method\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @returns {String} signed query string\n */\nPusher.prototype.createSignedQueryString = function (options) {\n  return requests.createSignedQueryString(this.config.token, options)\n}\n\nPusher.prototype.channelSharedSecret = function (channel) {\n  return crypto\n    .createHash(\"sha256\")\n    .update(\n      Buffer.concat([Buffer.from(channel), this.config.encryptionMasterKey])\n    )\n    .digest()\n}\n\n/** Exported {@link Token} constructor. */\nPusher.Token = Token\n/** Exported {@link RequestError} constructor. */\nPusher.RequestError = errors.RequestError\n/** Exported {@link WebHookError} constructor. */\nPusher.WebHookError = errors.WebHookError\n\nmodule.exports = Pusher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}